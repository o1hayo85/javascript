# 原始值与引用值

原始值：Undefined、Null、Boolean、Number、String、Symbol；引用值：Object

## 动态属性

对于引用值，可以随时给引用对象添加、修改和删除其属性和方法

```js
const person = new Object();
person.name = 'Jack';
console.log(person.name); // Jack

// *** 原始类型的初始化只能使用原始字面量形式，如果使用的是new关键字，则Javascript会创建一个Object类型的实例，但其行为类似原始值
```



## 复制值

原始值在通过变量把一个原始值赋值给另一个变量时，原始值会被复制到新的变量所在位置；引用值从一个变量赋值给另一个变量的时候，复制的实际上是指针，它指向内存在堆内存中的对象。操作完成后，两个变量实际上指向同一对象；

```js
const obj1 = new Object();
const obj2 = obj1;
obj1.name = 'Jack';
console.log(obj2.name) // Jack
```



## 传递参数

**ECMAScript中所有的函数的参数都是按值传递的。** 这就意味者函数外的值会被复制到函数内部的参数中，就像一个变量复制到另一个变量一样。如果是原始值，就跟原始值变量复制一样，如果是引用值，就跟引用值变量的复制一样；

```js
function setName(obj) {
    objl.name = 'Jack';
    obj = new Object(); // 此时的obj会随着函数执行完释放
    obj.name = 'Lucas'
}

const person = new Object();
setName(person);
console.log(person.name);
```



## 确定类型

对于引用类型，ECMAScript提供了instanceof操作符（**instanceof本质上是去调用对象上的Symbol.hasInstance方法去判断**）

```js
person instanceof Object // 变量person是Object吗？ 
```





# 执行上下文与作用域

==**重要理解**==

变量或函数的上下文决定了它们可以访问哪些数据以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上；变量对象无法使用代码访问，但是后台处理数据会用到。

全局上下文是最外层的上下文，就是js代码的执行环境。在浏览器中使用var定义的全局变量和函数都会称为window对象的属性和方法。使用let和const不会，但是作用域链解析的效果是一样的。上下文在其所有的代码执行完毕后才会销毁，包括定义在它上面的所有变量和函数(全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器)

每一个函数都有自己的上下文，当代码执行流进入函数时幂函数的上下文被推到一个上下文栈上。在函数执行完后，上下文栈会弹出该ii函数的上下文，并将控制权返回给之前的执行上下文

上下文中的代码在执行的时候，会创建变量对象的一个作用域链。代码正在执行的上下文变量对象始终位于作用域链的最前端。全局上下文的变量对象是作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。

==函数的参数被认为时当前上下文中的变量，因此也跟上下文中的其他变量遵循同样的访问规则==



## 作用域链增强

某一些语句会导致在作用域前端临时添加一个上下文，这个上下文在代码执行后会被删除。常见两个情况：

+ try/catch语句的catch块
+ with语句

```js
// 1.width语句
function buildUrl() {
    let qs = "?debug=true"
    
    with(location) {
        let url = href + qs;
    }
    return url;
}

// 2.catch语句
try {
    throw new Error('new Error')
} catch(err) {
    // err
}
```



## 变量声明

1. 使用var的作用域声明

   在使用var声明变量时，变量会自动添加到最接近的上下文。在函数中最接近的上下文就是函数的上下文。在with语句中也是函数上下文。==如果变量未声明就被初始化了，就会自动添加到全局上下汶==

   使用var声明会被拿到函数或全局作用域的顶部，位于作用域中所以的代码之前，称为**变量提升**

2. 使用let的作用域声明

   let关键字的作用域是块级的，块级作用域由最近的一对花阔（=={}==）含界定。let 与 var 的另一个不同之处是在同一作用域内不能声明两次。不能在声明之前使用let定义的变量。

3. 使用const的作用域声明

   使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值

```js
const o3 = Object.freeze({}); // 使用Obect.freeze({})创建的对象再给属性值虽然不会报错，但会静默失败。
o3.name = 'Jack';
console.log(o3.name); // undefined

// 由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例
// 都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化
```





# 垃圾回收

## 标记清理



## 引用计数



## 性能



## 内存管理

