# 变量

+ var

  1. var作用域，var的作用域包括函数作用域或所在script块中，但是在函数中省略var声明一个变量调用函数后会创建一个全局变量

     ```js
     function varTest() {
         a = 1
     }
     
     varTest()
     console.log(a) // 1
     ```

  2. var声明提升， 使用var声明的变量会自动提升到函数作用域的顶部

     ```js
     function foo() {
         console.log(age)
         var age = 26
     }
     foo() // undefined
     
     
     ```

  3. 重复声明。 使用var声明变量可以重复的声明某一个变量，声明变量所赋的值为最后一次的值

+ let

  1. let作用域 let声明的作用域是块作用域

     ```js
     if(true) {
         var age = 18;
         console.log(age); // 18
     }
     console.log(age); // 18
     
     /* 使用let定义 */
     if(true) {
         let age = 26;
         console.log(age); // 26
     }
     console.log(age); // ReferenceError
     ```

  2. 不会变量提升(暂时性死区)

  3. 不允许冗余声明

  4. 在全局作用域中声明不会变成window对象的属性

  5. for循环中的let声明，使用var循环定义的迭代变量会渗透到循环体外部(在外部能访问到)，使用let在循环体外部访问不到迭代变量

     ```js
     // 常见问题
     for(var i = 0; i < 5; i++) {
         setTimeout(() => console.log(i), 0)
     }
     
     // 5,5,5,5,5
     // 使用let定义则正常输出1，2，3，4，5
     
     // 拓展不适用let声明去让循环体正常输出
     function log(i) {
         console.log(i)
     }
     for(var i = 0; i < 5; i++) {
         setTimeout(() => {log(i)}, 0)
     }
     ```

     

+ const

  const的属性与let的基本一直，唯一重要区别就是const声明的同时必须初始化变量，却const声明的基本类型不能更改



+++



# 数据类型

JavaScript有六种简单数据类型：Undefined, Null, Boolean, Number, String, Symbol和一种复杂数据类型Object

| 类型      | 含义                                                         |
| :-------- | ------------------------------------------------------------ |
| undefined | 表示值未定义，使用var或let定义后没有初始化就相当与给变量赋值了undefined值 |
| boolean   | 表示值为布尔值                                               |
| string    | 字符串                                                       |
| number    | 数值                                                         |
| object    | 表示值为对象或者null                                         |
| function  | 表示值为函数                                                 |
| symbol    | 表示值为符号                                                 |
| null      | Null类型也只有一个值。null值表示一个空对象指针，所以typeof传入一个null会返回一个object |

## typeof

使用typeof能检测出的类型字符有; undefined, boolean, string, number, object, function, symbol



## Boolean

**不同类型和布尔值之间的转换规则**

| 数据类型  | 转换为true的值       | 转换为false的值 |
| --------- | -------------------- | --------------- |
| Boolean   | true                 | false           |
| String    | 非空字符串           | 空字符串        |
| Number    | 非零数值(包括无穷值) | 0/NaN           |
| Object    | 任意对象             | null            |
| Undefined | N/A                  | undefined       |



## Number

**Number类型使用IEEE754格式表示整数和浮点** [IEEE754详解](https://blog.csdn.net/gao_zhennan/article/details/120717424) ***还没看有时间了看***

1. 浮点值
2. 值的范围 Javascript中最小值为Number.MIN_VALUE, 最大值为Number.MAX_VALUE. 超过最大最小值的表示为Infinity不能再进行数学运算
3. NaN， 涉及任意包含NaN的操作将始终返回NaN，并且NaN不等于包含NaN在内的任何值，可以使用**isNaN()**函数来判断
4. 数值转换 **本质上都是先调用valueOf() 再调用NaN()进行转换**
   + **Number()**  一元加操作符于Number()函数遵循同样的转换规则
   + **parseInt(target, base)**  如果不传进制数，则会按照字符串内容默认解析
   + **parseFloat( target )** parseFloat只解析十进制数

```js
/* 几个关于Number的特殊转换 */
Number(new Date());// 1630248787885
Number('3a');// NaN
Number(undefined) // NaN
Number('011') // 11
Number('') // 0
Number('0xf') // 15, 包含有效的进制格式会转换为进制对应的十进制整数
// 使用Number转换Object时，会先调用valueOf()再进行转换，如果转换的结果是NaN，则调用toString()方法再按照字符串的转换规则进行转换

/* 几个关于parseInt的转换 */
parseInt('1.2e3');// 1 不能识别科学计数
parseInt(null) // NaN 不能转换空串和null

/* 几个关于parseFloat的转换 */
parseFloat('1234abc') // 1234
parseFloat('0xf') // 0 无法解析十六进制， 解析二进制和八进制会按十进制的值进行解析
parseFloat("0908.5") // 908.5
parseFloat('3a');// 3
parseFloat(null) // NaN 不能转换空串和null
```



## String

1. 字符字面量

   | 字面量 | 含义   |
   | ------ | ------ |
   | \n     | 换行   |
   | \t     | 制表符 |
   | \b     | 退格   |
   | \r     | 回车   |
   | \f     | 换页   |
   | \\\    | 反斜杠 |
   | \\'    | 单引号 |
   |        |        |

   特殊情况：如果字符串中包含双字节字符，那么 length 属性返回的值可能不是准确的字符数

2. 字符串的特点 immutable，字符串创建后不能被修改，要修改只能销毁再创建

3. 转换为字符串  [Number].toString(base)/String()[调用String()方法，如果值有toString()则调用并返回结果，没有则返回对应的类型]

4. 模板字面量和字符串插值 字符串所有插入的值都会调用toString方法强制转换为字符串

5. 模板字面量的标签函数

```js
// 标签函数

const name = 'yangxin'
const age = 22
let a = `I\'m ${name}, ${age} year old`
function foo(sting, ...rest) {
  console.log("🚀 ~ string", sting)
  console.log("🚀 ~ ...rest:", ...rest)
}
foo`I\'m ${name}, ${age} year old`
// "🚀 ~ string"： [I'm, ',', ' year old']
// 🚀 ~ ...rest: yangxin 22
```

6. 原始字符串 使用String.raw可以获取原始字符串



## Symbol

**符号是原始值，且符号实例是唯一的，不可变的。符号的用途是确保对象的属性使用唯一的标识符，不会发生属性冲突的危险**

1. 符号的基本用法

   ```js
   // 创建实例
   let symbol1 = Symbol();
   let symbol2 = Symbol();
   let symbol3 = Symbol('foo');
   let symbol4 = new Symbol(); // Symbol is not a constructor
   console.log(symbol1 == symbol2); // false
   
   ```

2. 全局符号注册表 Symbol.for() 如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册
   表中创建并重用符号

   ```js
   let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
   let otherGlobalSymbol = Symbol.for('foo'); // 重用已有的符号
   
   console.log(fooGlobalSymbol === otherGlobalSymbol) // true
   
   //Symbol.keyFor() 来查询全局注册表， 这个方法接受符号，返回全局符号对应的字符串键， 如果查询的不是全局符号则返回undefined
   ```

3. 使用符号作为属性 凡是可以使用字符串或者数值作为属性的地方都可以使用符号，包括Object.defineProperty()/Object.defineProperties()

   ```js
   // Object.getOwnPropertyNames()
   // Object.getOwnPropertySymbols()
   // Reflect.ownKeys()
   
   Object.defineProperties(obj, {
       [Symbol('symbol1')]: { value: 'val' },
       [Symbol('symbol2')]: { value: 'val' },
       normal: { value: 'val' }
   })
   
   console.log(Object.getOwnPropertySymbol(obj)); // [Symbol('symbol1'), Symbol('symbol2')]
   console.log(Object.getOwnPropertyNames(obj)); // ['normal']
   console.log(Reflect.ownKeys(obj)) // [Symbol('symbol1'), Symbol('symbol2')， 'normal']
   ```

   
