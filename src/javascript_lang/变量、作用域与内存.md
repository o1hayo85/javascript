# 原始值与引用值

原始值：Undefined、Null、Boolean、Number、String、Symbol；创建一个原始值变量时，会将变量的值保存在栈内存中，变量指向栈内存本身

引用值：Object；对于引用值： 当创建一个引用类型的变量时，js引擎会通过在栈内存中保存一个指向堆内存中对象实际数据的指针来实现

## 动态属性

对于引用值，可以随时给引用对象添加、修改和删除其属性和方法

```js
const person = new Object();
person.name = 'Jack';
console.log(person.name); // Jack

// *** 原始类型的初始化只能使用原始字面量形式，如果使用的是new关键字，则Javascript会创建一个Object类型的实例，但其行为类似原始值
```



## 复制值

原始值在通过变量把一个原始值赋值给另一个变量时，原始值会被复制到新的变量所在位置；引用值从一个变量赋值给另一个变量的时候，复制的实际上是指针，它指向内存在堆内存中的对象。操作完成后，两个变量实际上指向同一对象；

```js
const obj1 = new Object();
const obj2 = obj1;
obj1.name = 'Jack';
console.log(obj2.name) // Jack
```



## 传递参数

**ECMAScript中所有的函数的参数都是按值传递的。** 这就意味者函数外的值会被复制到函数内部的参数中，就像一个变量复制到另一个变量一样。如果是原始值，就跟原始值变量复制一样，如果是引用值，就跟引用值变量的复制一样；

```js
function setName(obj) {
    objl.name = 'Jack';
    obj = new Object(); // 此时的obj会随着函数执行完释放
    obj.name = 'Lucas'
}

const person = new Object();
setName(person);
console.log(person.name);
```



## 确定类型

对于引用类型，ECMAScript提供了instanceof操作符（**instanceof本质上是去调用对象上的Symbol.hasInstance方法去判断**）

```js
person instanceof Object // 变量person是Object吗？ 
```





# 执行上下文与作用域

==**重要理解**==

变量或函数的上下文决定了它们可以访问哪些数据以及它们的行为。每个上下文都有一个关联的变量对象，而这个上下文中定义的所有变量和函数都存在于这个对象上；变量对象无法使用代码访问，但是后台处理数据会用到。

全局上下文是最外层的上下文，就是js代码的执行环境。在浏览器中使用var定义的全局变量和函数都会称为window对象的属性和方法。使用let和const不会，但是作用域链解析的效果是一样的。上下文在其所有的代码执行完毕后才会销毁，包括定义在它上面的所有变量和函数(全局上下文在应用程序退出前才会被销毁，比如关闭网页或退出浏览器)

每一个函数都有自己的上下文，当代码执行流进入函数时幂函数的上下文被推到一个上下文栈上。在函数执行完后，上下文栈会弹出该ii函数的上下文，并将控制权返回给之前的执行上下文

上下文中的代码在执行的时候，会创建变量对象的一个作用域链。代码正在执行的上下文变量对象始终位于作用域链的最前端。全局上下文的变量对象是作用域链的最后一个变量对象。

代码执行时的标识符解析是通过沿作用域链逐级搜索标识符名称完成的。搜索过程始终从作用域链的最前端开始，然后逐级往后，直到找到标识符。（如果没有找到标识符，那么通常会报错。

==函数的参数被认为时当前上下文中的变量，因此也跟上下文中的其他变量遵循同样的访问规则==



## 作用域链增强

某一些语句会导致在作用域前端临时添加一个上下文，这个上下文在代码执行后会被删除。常见两个情况：

+ try/catch语句的catch块
+ with语句

```js
// 1.width语句
function buildUrl() {
    let qs = "?debug=true"
    
    with(location) {
        let url = href + qs;
    }
    return url;
}

// 2.catch语句
try {
    throw new Error('new Error')
} catch(err) {
    // err
}
```



## 变量声明

1. 使用var的作用域声明

   在使用var声明变量时，变量会自动添加到最接近的上下文。在函数中最接近的上下文就是函数的上下文。在with语句中也是函数上下文。==如果变量未声明就被初始化了，就会自动添加到全局上下汶==

   使用var声明会被拿到函数或全局作用域的顶部，位于作用域中所以的代码之前，称为**变量提升**

2. 使用let的作用域声明

   let关键字的作用域是块级的，块级作用域由最近的一对花阔（=={}==）含界定。let 与 var 的另一个不同之处是在同一作用域内不能声明两次。不能在声明之前使用let定义的变量。

3. 使用const的作用域声明

   使用 const 声明的变量必须同时初始化为某个值。一经声明，在其生命周期的任何时候都不能再重新赋予新值

```js
const o3 = Object.freeze({}); // 使用Obect.freeze({})创建的对象再给属性值虽然不会报错，但会静默失败。
o3.name = 'Jack';
console.log(o3.name); // undefined

// 由于 const 声明暗示变量的值是单一类型且不可修改，JavaScript 运行时编译器可以将其所有实例
// 都替换成实际的值，而不会通过查询表进行变量查找。谷歌的 V8 引擎就执行这种优化
```





# 垃圾回收

垃圾回收器的工作原理主要基于两个概念： 对象的可达性和引用计数

## 标记清理

标记清理使用的是对象的可达性，JavaScript中对象分为两种：可达对象和不可达对象。可达对象是指可以从根对象访问到的对象，如全局对象、函数调用栈中的变量、正在执行的函数参数和局部变量。而不可达对象就是指无法从根对象访问到的对象、这些对象已经没有任何引用指向它们。

标记清除算法主要分为两个阶段：

1. 标记阶段：从根对象开始遍历所有可达对象，并将他们标记为存活对象
2. 清除阶段：扫描整个堆，将所有未被标记的对象视为不可达对象，并将其释放

## 引用计数

引用计数基于对象被引用的次数来判断对象是否可达。每当一个对象被引用一次，他的引用计数就会叫1.当对象的引用计数为0时，就成为了一个不可达对象，就会被回收

但是存在一个明显问题，当两个对象或多个对象相互引用时，它们的引用计数都不为0，即使这些对象已经不被其他任何代码引用。

## 性能



## 内存管理

将内存量保持在一个较小的值可以让页面的性能更好。优化内存占用的最佳手段就是保证在执行代码时只保存必要的数据。如果数据不再必要，就将其设置为null，从而释放引用。局部变量在超出作用域后会被自动解除引用。

1. 通过const和let声明提升性能

   const和let更有利于垃圾回收提前介入（如果块作用域比函数作用域更早终止的情况下），因为const和let都以块为作用域

2. 隐藏类和删除操作

   ```js
   function Article() {
    this.title = 'Inauguration Ceremony Features Kazoo Band';
   }
   let a1 = new Article();
   let a2 = new Article(); 
   
   //V8 会在后台配置，让这两个类实例共享相同的隐藏类，因为这两个实例共享同一个构造函数和原型
   
   function Article() {
    this.title = 'Inauguration Ceremony Features Kazoo Band';
    this.author = 'Jake';
   }
   let a1 = new Article();
   let a2 = new Article();
   delete a1.author; 
   
   // 使用delete会导致生成相同的隐藏类片段
   ```

3. 内存泄漏

4. 静态分配与对象池

   
